package de.hype.hypenotify.app.screen;

import android.os.Bundle;
import android.view.View;
import android.widget.LinearLayout;
import androidx.activity.OnBackPressedCallback;
import androidx.annotation.NonNull;
import de.hype.hypenotify.app.MainActivity;
import de.hype.hypenotify.app.core.interfaces.Core;
import org.jetbrains.annotations.NotNull;

public abstract class Screen extends LinearLayout {
    protected final View parent;
    protected final Core core;
    private OnBackPressedCallback backPressedCallback;
    protected MainActivity context;
    protected LinearLayout dynamicScreen;

    // Auto-State-Management
    private String autoGeneratedScreenId;
    private boolean autoStateEnabled = true;

    public Screen(Core core, View parent) {
        super(core.context());
        context = core.context();
        this.core = core;
        this.parent = parent;

        // Auto-Screen-ID generieren basierend auf Klassenname
        autoGeneratedScreenId = this.getClass().getSimpleName().toLowerCase();

        // Screen-Klasse automatisch registrieren
        ScreenStateManager.getInstance().registerScreenClass(this.getClass());

        backPressedCallback = new OnBackPressedCallback(true) {
            @Override
            public void handleOnBackPressed() {
                close();
            }
        };
        context.getOnBackPressedDispatcher().addCallback(backPressedCallback);
    }

    public void close() {
        // Auto-State speichern vor dem Schließen
        if (autoStateEnabled) {
            autoSaveState();
        }

        if (backPressedCallback != null) {
            backPressedCallback.remove();
        }
        if (parent != null) {
            core.context().setContentView(parent);
            if (parent instanceof Screen screen) {
                screen.updateScreen();
            }
        } else {
            core.context().finish();
        }
    }

    /**
     * Auto-State-Management: Speichert automatisch den Zustand
     */
    private void autoSaveState() {
        try {
            Bundle state = new Bundle();

            // Standard-State sammeln
            saveBasicState(state);

            // Custom-State von abgeleiteter Klasse
            onSaveState(state);

            // State speichern mit korrekten Parametern
            ScreenStateManager.getInstance().saveScreenState(this, getScreenId(), state);

        } catch (Exception e) {
            android.util.Log.e("Screen", "Auto-save state failed for " + getScreenId(), e);
        }
    }

    /**
     * Auto-State-Management: Stellt automatisch den Zustand wieder her
     */
    public void autoRestoreState() {
        if (!autoStateEnabled) return;

        try {
            ScreenStateManager stateManager = ScreenStateManager.getInstance();
            if (stateManager.hasState(getScreenId())) {
                // Custom-State von abgeleiteter Klasse wiederherstellen
                Bundle state = stateManager.getStateBundle(getScreenId());
                if (state != null) {
                    restoreBasicState(state);
                    onRestoreState(state);
                }
            }
        } catch (Exception e) {
            android.util.Log.e("Screen", "Auto-restore state failed for " + getScreenId(), e);
        }
    }

    /**
     * Sammelt Standard-State-Informationen
     */
    private void saveBasicState(Bundle state) {
        // Scroll-Position falls ScrollView vorhanden
        if (dynamicScreen != null) {
            state.putInt("scroll_y", dynamicScreen.getScrollY());
        }

        // Visibility-Status
        state.putInt("visibility", getVisibility());

        // Timestamp
        state.putLong("state_timestamp", System.currentTimeMillis());
    }

    /**
     * Stellt Standard-State-Informationen wieder her
     */
    private void restoreBasicState(Bundle state) {
        // Nach Layout-Update anwenden
        post(() -> {
            // Scroll-Position
            int scrollY = state.getInt("scroll_y", 0);
            if (dynamicScreen != null && scrollY > 0) {
                dynamicScreen.scrollTo(0, scrollY);
            }

            // Visibility
            int visibility = state.getInt("visibility", View.VISIBLE);
            setVisibility(visibility);
        });
    }

    /**
     * Override diese Methode um Custom-State zu speichern
     *
     * @param state Bundle zum Speichern der Daten
     */
    protected void onSaveState(Bundle state) {
        // Default: Nichts speichern
        // Überschreiben in abgeleiteten Klassen bei Bedarf
    }

    /**
     * Override diese Methode um Custom-State wiederherzustellen
     *
     * @param state Bundle mit gespeicherten Daten
     */
    protected void onRestoreState(Bundle state) {
        // Default: Nichts wiederherstellen
        // Überschreiben in abgeleiteten Klassen bei Bedarf
    }

    /**
     * Gibt die Screen-ID zurück (auto-generiert oder custom)
     */
    public String getScreenId() {
        return autoGeneratedScreenId;
    }

    /**
     * Ermöglicht es, eine custom Screen-ID zu setzen
     */
    protected void setScreenId(String customId) {
        this.autoGeneratedScreenId = customId;
    }

    /**
     * Aktiviert/Deaktiviert Auto-State-Management
     */
    protected void setAutoStateEnabled(boolean enabled) {
        this.autoStateEnabled = enabled;
    }

    public final void resetDynamicScreen() {
        if (dynamicScreen != null) {
            dynamicScreen.removeAllViews();
            removeView(dynamicScreen);
        }
        dynamicScreen = getDynamicScreen();
        addView(dynamicScreen);
    }

    public final void updateScreen() {
        removeAllViews();
        if (dynamicScreen != null) {
            dynamicScreen.removeAllViews();
        }
        try {
            inflateLayouts();
            LinearLayout newDynamicScreen = getDynamicScreen();
            updateScreen(newDynamicScreen);
            if (newDynamicScreen != null) {
                if (newDynamicScreen.getParent() == null) {
                    if (dynamicScreen != null) removeView(dynamicScreen);
                    addView(newDynamicScreen);
                }
                dynamicScreen = newDynamicScreen;
            }

            // State nach Update wiederherstellen
            autoRestoreState();

        } catch (Throwable e) {
            e.printStackTrace();
        }
    }

    /**
     * Inflate all layouts you need here. Called before the Dynamic Screen is obtained to give you back at update Screen.
     */
    protected abstract void inflateLayouts();


    /**
     * The View is the Dynamic Screen you returned in {@link #getDynamicScreen()}
     */
    protected abstract void updateScreen(LinearLayout dynamicScreen);

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        // Clean up the callback when the view is detached
        if (backPressedCallback != null) {
            backPressedCallback.remove();
        }
    }
    public abstract void onPause();
    public abstract void onResume();
    protected abstract LinearLayout getDynamicScreen();

    @NonNull
    @Override
    public @NotNull String toString() {
        return this.getClass().getSimpleName();
    }
}
